# Regis Boudinot - M1 Portfolio

## Individual

### Areas of Emphasis

Coming into this module I felt weak on ruby. I had self taught myself the basic
syntax but felt very weak on enumerables, working with hashes, and manipulating
arrays. I had never even made a class or a method before. I feel as if I have
learned more than I could even imagine learning so far. I am really pleased
with my progress so far. Ruby is now more of a playground than a minefield.

Initially I also struggled with understanding the concept behind TDD
but now I am driving my code with tests and refactoring methods as I go.

### End of Module Assessment

* Ruby Syntax:
* Rails Basics:
* Javascript Basics:
* Workflow:
* Collaboration:

### Attendance

This module I attended all days and classes on-time. I came in an hour early
most of the time to get ready for the day.

### Work

I completed the following individual work this module:

#### Chisel

* [Project URL](https://github.com/turingschool/curriculum/blob/master/source/projects/chisel.markdown)
* [GitHub URL](https://github.com/selfup/chisel)

### Notes

* Overall good progress
* Some gaps / further room to grow in the testing
* Like that it works!
* Implementations are ok but need some refactoring

### Scores

* Fundamental Ruby & Style: 3
* Test-Driven Development: 2
* Functionality: 3
* Breaking Logic into Components: 3

#### Linked List

* [GitHub URL](https://github.com/selfup/linked_list)

Notes

Could use some edge case testing
Tail method had a iterative and recursive version
be careful not to use local variable names that match a method
Good that the count method is SRP
Scores

Functional Expectations: 4
Test-Driven Development: 3
Encapsulation: 3
Fundamental Ruby & Style: 3
Looping / Recursion: 3.5

## Team

* GitHub URL: https://github.com/selfup/enigma

#### Notes

#### Scores

* Functionality:
  * Score: 4
* Fundamental Ruby & Style:
  * Score: 3
* Test-Driven Development:
  * Score: 3-
* Breaking Logic into Components:
  * Score: 2
  * Use the interface before it exists, so that you can discover what it should be.
    This will lead to elegance.
  * Prefer interfaces where there is no way for the object to be used wrong
    (ie don't let other objects coordinate the methods of this object)
  * If the object is a verb (crack, encrypt, decrypt -- vs key, date, etc),
    choose interfaces like "here are your inputs, give me the output",
    this omits "state" (instance variables) and thus will lead to the above suggestions.
    eg `Crack.new(encrypted_message).crack` ...or, given the "functions" style we talked about
    during modules yesterday: `Crack.call(encrypted_message)`

### Feedback to Me

## Community

### Giving Feedback

### Playing a Part

* On Monday, July 27th, I had my blog post ("The Difference is Huge") included in
that week's Posse Post as well as being featured on the Turing Blog.
* On Friday, July 3rd, I helped cater Andrew's City of Cuernavaca Park picnic.
